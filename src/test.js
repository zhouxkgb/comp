// 给定一个长度为n的整型数组，表示一个选手在n轮内可选择的牌面分数。选手基于规则选牌，请计算所有轮结束后其可以获得的最高总分数。选择规则如下：
// 1、在每轮里选手可以选择获取该轮牌面，则其总分数加上该轮牌面分数，为其新的总分数。
// 2、选手也可不选择本轮牌面直接跳到下一轮，此时将当前总分数还原为3轮前的总分数，若当前轮次小于等于3（即在第1、2、3轮选择跳过轮次），则总分数置为0。
// 3、选手的初始总分数为0，且必须依次参加每一轮。

// 输入描述:
// 第一行为一个小写逗号分割的字符串，表示n轮的牌面分数，1<= n <=20。
// 分数值为整数，-100 <= 分数值 <= 100。
// 不考虑格式问题。

// 输出描述:
// 所有轮结束后选手获得的最高总分数。

// 示例1
// 输入
// 1,-5,-6,4,3,6,-2
// 输出
// 11

// 说明
// 总共有7轮牌面。
// 第一轮选择该轮牌面，总分数为1。
// 第二轮不选择该轮牌面，总分数还原为0。
// 第三轮不选择该轮牌面，总分数还原为0。
// 第四轮选择该轮牌面，总分数为4。
// 第五轮选择该轮牌面，总分数为7。
// 第六轮选择该轮牌面，总分数为13。
// 第七轮如果不选择该轮牌面，则总分数还原到3轮1前分数，即第四轮的总分数4，如果选择该轮牌面，总分数为11，所以选择该轮牌面。
// 因此，最终的最高总分为11。

function calcScore(str) {
    let score = 0
    const scores = str.split(',').map(v => +v)
    const tmp = []
    for (let i = 0, len = scores.length; i < len; i++) {
        if (scores[i] >= 0) { // 选择牌面
            score += scores[i]
            tmp.push(scores[i])
        } else {
            // scores[i]<0
            if (tmp.length < 3) {
                if (score + scores[i] < 0) {
                    score = 0 // 跳过
                } else {
                    score += scores[i]  // 选择牌面
                    tmp.push(scores[i])
                }
            } else {
                let temp = score - tmp.at(-1) - tmp.at(-2)
                if (score + scores[i] < temp) {
                    score = temp // 跳过
                } else {
                    score += scores[i]  // 选择牌面
                    tmp.push(scores[i])
                }
            }
        }
    }
    console.log(score)
}

let str = '1,-5,-6,4,3,6,-2'
let s2 = '1,2,3'
let s3 = '-1,-2,-3'
let s4 = '1,10,-2,20,1,0,-5'
// calcScore(str) // 11
// calcScore(s2)// 6
// calcScore(s3)// 0
// calcScore(s4)// 29



// 同一个数轴X上有两个点的集合A={A1, A2, …, Am}和B={B1, B2, …, Bn}，Ai和Bj均为正整数，A、B已经按照从小到大排好序，A、B均不为空，给定一个距离R(正整数)，列出同时满足如下条件的所有（Ai, Bj）数对：
// 1）Ai <= Bj
// 2）Ai, Bj之间的距离小于等于R
// 3）在满足1）2）的情况下，每个Ai只需输出距离最近的Bj
// 4）输出结果按Ai从小到大的顺序排序
// 输入描述:
// 第一行三个正整数m，n，R
// 第二行m个正整数，表示集合A
// 第三行n个正整数，表示集合B
// 输入限制：
// 1<=R<=100000，1<=n,m<=100000，1<=Ai,Bj<=1000000000
// 输出描述:
// 每组数对输出一行Ai和Bj，以空格隔开
// 示例1
// 输入
// 4 5 5
// 1 5 5 10
// 1 3 8 8 20
// 输出
// 1 1
// 5 8
// 5 8
